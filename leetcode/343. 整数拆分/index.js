// 推测出来一个整数要拆成多个 2 和 3 的和，就能保证乘积最大。
// 原理很容易理解，因为 2 和 3 可以合成任何数字，例如5=2+3，但是5 < 2*3；例如6=3+3，但是6<3*3。
// 所以根据贪心算法，就尽量将原数拆成更多的 3，然后再拆成更多的 2，保证拆出来的整数的乘积结果最大。

// 但上面的解法还有不足。如果整数 n 的形式是 3k+1，例如 7。
// 按照上面规则，会拆分成“3 + 3 + 1”。但是在乘法操作中，1 是没作用的。
// 此时，应该将 1 和 3 变成 4，也就是“3 + 3 + 1”变成“3 + 4”。此时乘积最大。

// 综上所述，算法的整体思路是：

// n 除 3 的结果为 a，余数是 b
// 当 b 为 0，直接将 a 个 3 相乘
// 当 b 为 1，将（a-1）个 3 相乘，再乘以 4
// 当 b 为 2，将 a 个 3 相乘，再乘以 2
// 空间复杂度是 O(1)，时间复杂度是 O(1)。代码实现如下：


/**
 * @param {number} n
 * @return {number}
 */
var integerBreak = function(n) {
  if(n === 2) return 1;
  if(n === 3) return 2;
  let a = Math.floor(n / 3);  //a 代表 n 最多可以拆分成多少个3
  let b = n % 3;              //b 代表 n 拆分后的余数
  if(b === 0) return Math.pow(3, a);
  if(b === 1) return Math.pow(3, a-1) * 4;
  return Math.pow(3, a) * 2;
};

console.log(integerBreak(5))